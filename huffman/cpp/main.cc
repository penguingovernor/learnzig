#include <sys/types.h>

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <iostream>
#include <vector>

struct Node {
  uint8_t symbol;
  size_t frequency_count;
  Node *left;
  Node *right;
};

static constexpr char interior_node = '*';
static constexpr uint8_t compress_me[] = {
    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x65,
    0x73, 0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x49,
    0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70,
    0x6c, 0x65, 0x20, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65,
    0x20, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65,
    0x78, 0x74, 0x2e, 0x0a, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x5a, 0x69,
    0x67, 0x27, 0x73, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67,
    0x20, 0x69, 0x73, 0x20, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x2c, 0x20, 0x69,
    0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x73, 0x75, 0x70,
    0x70, 0x6f, 0x72, 0x74, 0x20, 0x65, 0x6d, 0x6f, 0x6a, 0x69, 0x73, 0x21,
    0x0a, 0x48, 0x65, 0x72, 0x65, 0x27, 0x73, 0x20, 0x6f, 0x6e, 0x65, 0x20,
    0x6e, 0x6f, 0x77, 0x3a, 0x20, 0x28, 0xf0, 0x9f, 0xa6, 0x8e, 0x29, 0x0a,
    0x49, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74,
    0x20, 0x73, 0x65, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x62, 0x6f,
    0x76, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x27, 0x73, 0x20, 0x61, 0x6e, 0x20,
    0x69, 0x67, 0x75, 0x61, 0x6e, 0x61, 0x21, 0x0a, 0x0a, 0x46, 0x75, 0x6e,
    0x20, 0x66, 0x61, 0x63, 0x74, 0x3a, 0x20, 0x5a, 0x69, 0x67, 0x20, 0x70,
    0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x6d, 0x65, 0x72, 0x27, 0x73, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x5a, 0x69, 0x67, 0x75, 0x61, 0x6e, 0x61, 0x73,
    0x21,
};

void free_tree(Node *root) {
  if (root == nullptr) return;
  free_tree(root->left);
  free_tree(root->right);
  free(root);
}

int main(void) {
  // Make a histogram.
  std::array<uint8_t, 256> histogram = {0};
  for (size_t i = 0; i < sizeof compress_me - 1; i++) {
    histogram[i]++;
  }
  // Make the tree of nodes.
  std::vector<Node *> nodes;
  for (size_t i = 0; i < histogram.size(); i++) {
    if (histogram[i] == 0) {
      continue;
    }
    nodes.push_back(new Node{
        .symbol = (uint8_t)i,
        .frequency_count = histogram[i],
        .left = nullptr,
        .right = nullptr,
    });
  }
  // Heapify the "tree"
  const auto cmp = [](const Node *left, const Node *right) -> bool {
    return left->frequency_count < right->frequency_count;
  };
  std::make_heap(nodes.begin(), nodes.end(), cmp);

  // Build the tree.
  const auto pop = [&](std::vector<Node *> &heap) -> Node * {
    std::pop_heap(heap.begin(), heap.end(), cmp);
    auto ret = heap.back();
    heap.pop_back();
    return ret;
  };
  while (nodes.size() > 1) {
    auto left = pop(nodes);
    auto right = pop(nodes);
    nodes.push_back(new Node{
        .symbol = interior_node,
        .frequency_count = left->frequency_count + right->frequency_count,
        .left = left,
        .right = right,
    });
  }

  const auto root = nodes.back();

  free_tree(root);
}
